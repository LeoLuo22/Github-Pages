title: 至少你得知道字符集和编码
---
是否想过神秘的Content-Type标签？你知道的，就是你应该放在HTML里面的，但是你从来不是否清楚里面是什么？

你是否收到你的朋友从保加利亚发过来的主题为"????????"的邮件？

我很沮丧的发现很多程序员都不是很了解字符集，编码，Unicode等等。数年以前，一个FogBUGZ的测试人员在想它是否可以处理收到的日文邮件。日文？他们用日文发送邮件？我完全没有头绪。当我进一步研究商用的用来解析MIME邮件内容ActiveX，我们发现它对字符集的做法完全是错误的，所以我们必须编写史诗般的代码来撤销它解析出错误的对话然后重新使他正确。当我研究另一个商用库的时候，同样的，完全打坏了字符编码的实现。我联系了那个开发人员，然而他表示他无能为力。和许多程序员一样，他希望bug能够诡异的消失。

但是Bug可不这么想。当我发现流行的web开发工具PHP几乎完全忽略了字符编码问题，愉快的使用8位字符编码，使得PHP几乎不可能开发出国际web应用，我想，enough is enough.

所以我有一份声明：如果你是一个2003年的程序员，然而亦不知道基本的字符，字符集，编码和Unicode，我鄙视你。我会通过让你剥六个月的洋葱来惩罚你。

另一件事：
----------------------------------------**它并没有那么难**-----------------------------------------------

在这边文章里，我会让你知道*每一个工作的程序员*都应该知道的。关于"plain text=ascii=characters are 8 bits"并不仅仅是错，更是没希望的错，如果你那样编程的话，你比一个不信细菌的医生好不了哪去。当你阅读完这篇文章以前，请不要再写任何一行代码。
在我开始之前，我应该提醒你如果你是极少数的了解国际化的人，你将会知道我的文章有一点过于简单。我只是想设定一个底线，任何人都能明白是怎么回事，可以编写在任何语言都有*希望*运行的代码，而不仅仅是英语。我也应该提醒你字符处理只是创建国际化软件的一小部分，但是我一次只能叙述一次事情，所以今天我就讲字符集。

----------

## 历史角度

最简单的理解方式是按年代顺序来。
你可能会想我会谈论古老的字符集比如EBCDIC。然而我并不会，EBCDIC和你的生活并不相关。我们不需要走得那么远。

回到中古世纪，当Unix被发明,K&R开始编写The C Programming Language，一切都很简单。EBCDIC逐渐出局。字符只与英文字符有关，我们有一套叫做**ASCII**编码，它可以使用32和127之间的数字表示每一个字符。空格是32，"A"是65，等等。字符可以方便的被存储为7位。这些时候的大多数计算机使用8位，所以你不仅可以保存每一个ASCII字符，你还有1位的空余，这样，如果你邪恶的话，你可以用于你不那么光明的目的:WordStar昏暗的灯泡把高位用来表明一个单词中最后的一个字母，使得WordStar局限在英文文本中。小于32的编码被称为*不可打印的*，是用来被诅咒的。开玩笑的，他们被用作控制符，比如7可以使你的计算机beep，12使你paper的当前页被传送到打印机，接着新的页面会被送进。

一切都很好，如果你说英语的话。

因为还有1位的空闲，许多人开始想，“天呐，我们可以用128-255的编码来实现我们自己的目的”。问题是，许多人在同一时间都有这个主意，而且他们对128-255的想法也各不相同。IBM-PC有一些被周知的事情因为OEM字符集提供给欧洲语言以及一系列的划线字符...水平bar，垂直bar等等，你可以使用这些线来制作图。事实上，当美国以外的人们开始购买PC的的时候，各种各样的OEM字符集开始出现，都是使用128以上的字符来实现他们自己目的。举个栗子，一些PC上的字符130会被显示e/,但是其他被卖到以色列的PC会被显示为Gimel，所以当美国人发送re/sume/给以色列的时候，会被解析错误。许多情况下，比如俄罗斯，有许多关于128以上字符编码的处理，所以你几乎不能阅读俄罗斯的文档。

最终，OEM。在ANSI标准下，每个人对小于128的字符编码没有意见，这与ASCII很像，但是有很多的想法来处理大于128位的编码，取决于你生活在哪。这些不同的系统被称为**code pages**。举个栗子，以色列的DOS使用叫做862的code page，希腊使用737。他们在128位一下都一样但是128以上都不相同。国际版的MS-DOS有许多这样的code pages，处理从英文到冰岛文。但是，当希伯来文和雅典文在同一台电脑上是绝不可能的，除非你编写自己的程序使用位图映射来显示内容，因为希伯来文和雅典文需要不同的code pages，这对高位的数字的翻译是不同的。

同时，在亚洲，更多疯狂的事情要被考虑，亚洲的字母表有成千上万个字符，这些用8位满足不了。这些通常被一个叫做DBCS的混乱系统解决，即双字节字符集(double byte character set)，一些字符被单字节存储，一些被双字节存储。在字符串前进很容易，但是后退几乎不可能。程序员们被建议不要使用s++和s-来后移和前移，而是通过调用函数，比如Windows的AnsiNext和AnsiPerv。

但是，许多人假装一个字节是一个字符，一个字符是8位，只要你永远不把一个字符串从一台计算机转移到另一个计算机，或者不用另一种语言，总是不会出Bug的。但是理所当然的是，只要互联网在，把一个字符串在计算机之间转移会变得很普遍，接着所有的麻烦混乱就会来临。幸运的是，unicode被发明了。

----------
## Unicode
Unicode在创建一套单独的包含星球上任何书写系统的字符集上做了很大的努力。一些人可能会有错觉，认为Unicode只是简单的16位编码，每个字符占据16位，所以有65536中可能的字符。**这是绝对错的。**这是对Unicode最普遍的误解，如果你也是那么想的，不要感到难过。

事实上，Unicode关于字符有不同的想法，你必须通过思考来理解Unicode。

目前为止，我们假设一个字母被映射为你可以存储在内存或者磁盘上的位数:

A -> 0100 0001

在Unicode里，一个字母被映射到被称为*code print*的东西上，这是一个理论上的概念。code print如何在内存或者磁盘上被表示的又是另一个完全不同的故事了。

在Unicode中，字母A是柏拉图式理想化的。他就想漂浮在天堂:
  -----------------------------------A-----------------------------------

这个柏拉图式的A和B不同，和a也不同，但是和A，**A**，*A*都相同。关于A在不同字体间的相同但是在大小写间的不同的想法，看起来并不是十分有争议，但是在一些语言中，弄清楚一个字母到底是什么还是有争议的。德国的字母β是一个真正的字母还是ss的另一种写法？希伯来人说是，阿拉伯人说不是。不管怎样，Unicode联盟中的聪明人在过去的数十年已经弄清楚这个了，伴随着大量的政治辩论，然而你不需要担心。他们早已看穿一切。

每个字母表里的理想化字母被Unicode联盟分配了一个魔力数字，它看起来是这样：**U+0639**。这个魔力数字被称为*code print*。U+表示"Unicode"，后面的数字是十六进制的。U+0639是阿拉伯字母Ain。英文字母A是U+0041。你可以在Unicode官方网站找到完整的映射图。

Unicode定义字符的数字位数并没有限制，事实上早已超过了65536，所以并不是每一个Unicode字符都可以化为两个字节，也许更多。

以一个字符串为例：

--------------------------**Hello**----------------------------------

在Unicode中，是

U+0048 U+0065 U+006C U+006C U+006F

就是一串编码。但是，目前我们并没有谈论如何在内存中存储这些以及如何在Email中表示出来。

## Encodings
接着，**编码**来了。

Unicode编码最初的想法，导致了两个字节的谜团。让我们把那些数字用两个字节存储。所以Hello变成了

00 48 00 65 00 6C 00 6C 00 6F

对吗？操之过急。他是否也可能是:

48 00 65 00 6C 00 6C 00 6F 00 ?

技术上来说，是的。我相信这是可行的。事实上，早期的实现者们想要把他们的Unicode code points存储到高位或者低位，取决于他们特定的CPU在哪个上更快。所以人们被迫进行了一场奇特的会议，讨论在每个Unicode字符串的开始存储一个Fe FF。这被称为一个Unicode Byte Order Mark。如果你交换了你的高位和地位，那么就会变成FF FE，读你的字符串的人就知道他们必须交换其他的每个字节。

在一段时间内，一切看起来都很好。但是程序员开始抱怨:看看那么多的0，因为他们是美国人，所以他们使用的英文文本很少超过U+00FF。由于这个原因，许多人决定忽视Unicode，同时事情变得更糟了起来。

因此发明了**UTF-8**的概念。UTF-8是存储字符串的另一个系统。在UTF-8中，每个在0-127的code point被存储为一个*单字节*。只有超过128的才被存储为2，3最多6个字节。

图片。

这样的话英文文本在UTF-8和ASCII中的表现几乎一样，所以美国人几乎没有注意到任何错误。只有世界上的其他人跳出了这个圈。**Hello**,即U+0048 U+0065 U+006C U+006C U+006F,会被存储为48 65 6C 6C 6F，就像被存储在ASCII中一样。

目前为止，我已经告诉你三种Unicode编码。传统的存储为两个字节的叫做UCS-2（因为他有两个字节）或者UTF-16（因为有16位），你需要分别他是高位的UCS-2还是低位的UCS-2.然后就是流行的UTF-8标准。

事实上还有许多其他编码Unicode的方式。比如UTF-7，很UTF-8很像，但是确保高位是0。还有USC-4，以四个字节来存储每个code point。

## 关于编码最重要的一件事
如果你完全忘了我之前阐述的一切，请记住最重要的一条：**如果不知道一个字符串使用的编码是毫无意义的**。你不能把你的头埋在沙子里假装"plain"文本是ASCII。

**并没有纯文本(There Ain't No Such Thing As Plain Text)**

如果你有一个字符串，在内存，在文件，在email里，你需要知道他使用什么编码，否则你不能翻译或者正确的展示给用户。

我们如何保存字符串使用的编码信息？有许多方法。对Email来说，你需要在表单的header添加：

**Content-Type: text/plain;charset="UTF-8"**

对网页来说，原始想法是服务器会和网页一起返回一个相同的Content-Type的http header--并不是在HTML里面，是在响应头里面。

这就出现问题了，假如你有一个大型网站，由不同地区使用不同语言的人维护。服务器自己并不知道每个文件是由什么编码写的，所以它不能发送Content-Type头。

这样的话在HTML文件里面放置编码格式就很方便了...但是在你不知道编码是什么之前你怎么阅读HTML文件呢？幸运的是，几乎所有的编码使用32到127的字符，所以你可以在HTML文件里面声明。

<html>
<head>
<meta http-equiv="Content-Type" content="text/htm; charset=utf-8">

